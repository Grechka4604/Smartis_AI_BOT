<h3>Поля лога</h3><table><colgroup><col /><col /></colgroup><tbody><tr><td style="text-align: center;">Поле</td><td style="text-align: center;">Описание</td></tr><tr><td>created_at</td><td><p>Дата начала построения</p></td></tr><tr><td>updated_at</td><td><p>Дата завершения построения</p></td></tr><tr><td>uuid</td><td><p>Уникальный идентификатор лога</p></td></tr><tr><td>env</td><td><p>Окружение построения (local/dev/production)</p></td></tr><tr><td>server</td><td><p>Сервер в котором происходило построение (local/dev/stage/prod)</p></td></tr><tr><td>sapi</td><td><p>Тип интерфейса PHP (fpm-fcgi/cli)</p></td></tr><tr><td>deployment_name</td><td><p>Название deployment-а, в котором запущено построение (api/php/synchronization/queue-*)</p></td></tr><tr><td>client_id</td><td><p>Идентификатор клиента</p></td></tr><tr><td>user_id</td><td><p>Идентификатор пользователя, вызвавшего построение</p></td></tr><tr><td>widget_id</td><td><p>Идентификатор виджета, в рамках которого строим отчёт</p></td></tr><tr><td>metric_id</td><td><p>Идентификатор показателя, который строим</p></td></tr><tr><td>parent_uuid</td><td><p>Ссылка на лог, в рамках которого собирали статистику по нынешнему построению</p></td></tr><tr><td>input_data_days</td><td><p>Количество дней в интервале $input_data_from и $input_data_to</p></td></tr><tr><td>filter_date_days</td><td><p>Количество дней в интервале $filter_date_from и $filter_date_to</p></td></tr><tr><td>metric_group_id</td><td><p>Показатель, который запросил пользователь</p></td></tr><tr><td>metric_parent_id</td><td><p>Показатель из-за которого был построен отчёт по показателю лога</p></td></tr><tr><td>get_query_result_ms</td><td><p>Сколько времени заняло выполнения запроса к БД, миллисекунд</p></td></tr><tr><td>report_class</td><td><p>Полное название класса отчёта</p></td></tr><tr><td>report_method</td><td><p>Метод класса отчёта, через который идёт построение</p></td></tr><tr><td>build_time_ms</td><td><p>Время построения отчёта с учётом кэша, миллисекунд</p></td></tr><tr><td>raw_build_time_ms</td><td><p>Время построения отчёта вне кэша, миллисекунд</p></td></tr><tr><td>is_model_attributions_injected</td><td><p>Произошло ли внедрение разложения по МА на лету?</p></td></tr><tr><td>model_attribution_inject_ms</td><td><p>Затраченное время на разложение по МА, миллисекунд</p></td></tr><tr><td>ma_direct</td><td><p>Включать ли прямой трафик?</p></td></tr><tr><td>ma_period</td><td><p>За это количество дней до конверсии будут взяты касания, иначе называют &laquo;Окно ретроспективы&raquo;</p></td></tr><tr><td>ma_model_id</td><td><p>Идентификатор модели атрибуции</p></td></tr><tr><td>ma_date_class</td><td><p>Информация о том, откуда брать дату для анализа по моделям атрибуции</p></td></tr><tr><td>ma_label_class</td><td><p>Информация о том, какое поле нужно в связанных сущностях</p></td></tr><tr><td>features.process_id</td><td><p>Идентификатор пода/процесса, в котором запущено построение</p></td></tr><tr><td>features.build_type</td><td><p>Тип построения (групповой показатель/единичный показатель)</p></td></tr><tr><td>features.group_by</td><td>Группировка</td></tr><tr><td>features.compare_mode</td><td><p>Пользователь запрос отчёт в режиме сравнения?</p></td></tr><tr><td>features.report_type</td><td>Тип отчёта</td></tr><tr><td>features.input_data_from</td><td><p>Что указано в параметрах пользователя: Календарь от</p></td></tr><tr><td>features.input_data_to</td><td><p>Что указано в параметрах пользователя: Календарь до</p></td></tr><tr><td>features.query</td><td><p>Какой запрос отправили в БД</p></td></tr><tr><td>features.can_use_cache</td><td><p>Должны ли мы воспользоваться кэшем при отправке запроса к БД?</p></td></tr><tr><td>features.got_from_cache</td><td><p>Получили ли мы результат запроса из кэша?</p></td></tr><tr><td>features.can_use_slave</td><td><p>Могли ли мы отправить запрос в slave?</p></td></tr><tr><td>features.wait_for_query_in_temporary_ms</td><td><p>Сколько времени ждали, пока данные дотекут из master в slave, миллисекунд</p></td></tr><tr><td>features.wait_for_unlock_metrics_table_ms</td><td><p>Сколько времени ждали разблокировки таблицы показателя, миллисекунд</p></td></tr><tr><td>features.apply_filters_after_query_ms</td><td><p>Сколько времени заняло применение фильтров после выполнения запроса, миллисекунд</p></td></tr><tr><td>features.after_query_ms</td><td><p>Сколько времени занял метод afterQuery(), миллисекунд</p></td></tr><tr><td>features.build_sources_groups_ms</td><td><p>Сколько времени занял метод buildSourcesGroups, миллисекунд</p></td></tr><tr><td>features.before_query_execution_handler_ms</td><td><p>Сколько времени занял метод beforeQueryExecutionHandler, миллисекунд</p></td></tr><tr><td>features.before_query_ms</td><td><p>Сколько времени занял метод beforeQuery(), миллисекунд</p></td></tr><tr><td>features.report_class_short</td><td><p>Короткое название класса отчёта (последнее слово после &quot;&quot;)</p></td></tr><tr><td>features.should_use_report_cache</td><td><p>Должны ли мы задействовать кэш для результата построения отчёта?</p></td></tr><tr><td>features.is_compare</td><td><p>Отчёт строится в режиме &quot;сравнение&quot;?</p></td></tr><tr><td>features.report_cache_used</td><td><p>Хотели ли мы задействовать кэш для результата построения отчёта?</p></td></tr><tr><td>features.serialize_rmd_after_build_ms</td><td><p>Время на сериализацию rmd после того, как отчёт был построен, миллисекунд</p></td></tr><tr><td>features.deserialize_rmd_from_cache_ms</td><td><p>Время на десериализацию rmd после извлечения результата построения отчёта из кэша, миллисекунд</p></td></tr><tr><td>features.set_condition_for_sites_ms</td><td><p>Время на проставление условий привязок, миллисекунд</p></td></tr><tr><td>features.set_condition_for_filters_ms</td><td><p>Время на проставление условий из фильтров, миллисекунд</p></td></tr><tr><td>features.filter_applied</td><td><p>Переданный фильтр был применён к отчёту</p></td></tr><tr><td>features.cohort_filter_applied</td><td><p>Был использован когортный фильтр?</p></td></tr><tr><td>features.filter_injection_ms</td><td><p>Время на проставление условий фильтров, миллисекунд</p></td></tr><tr><td>features.is_cohort_report</td><td><p>Указано ли в свойства отчёта, что использована когорта?</p></td></tr><tr><td>features.has_date_period_filter</td><td><p>Были ли использован фильтр по дате?</p></td></tr><tr><td>features.filter_date</td><td><p>Поле даты, по которому фильтровали</p></td></tr><tr><td>features.filter_date_is_unix</td><td><p>Поле даты, по которому фильтровали, является числом?</p></td></tr><tr><td>features.filter_date_from</td><td><p>Дата начала периода фильтрации</p></td></tr><tr><td>features.filter_date_to</td><td><p>Дата завершения периода фильтрации</p></td></tr><tr><td>features.is_ma_should_injected</td><td><p>Должно ли было произойти разложение по МА на лету?</p></td></tr><tr><td>features.ma_crm_account_id</td><td>CRM account id</td></tr><tr><td>features.ma_element_type_id</td><td>Element type id</td></tr><tr><td>features.ma_date_is_unix</td><td><p>Дата МА в таблице хранится в int?</p></td></tr><tr><td>features.ma_date_field_id</td><td><p>Идентификатор доп. поля даты конверсии</p></td></tr><tr><td>features.ma_date_column</td><td><p>Название поля МА в таблице</p></td></tr><tr><td>features.ma_date_table</td><td><p>Таблица поля МА</p></td></tr><tr><td>features.ma_date_expression</td><td><p>Выражение, которое необходимо выполнить над полем. В качестве placeholder-а необходимо использовать даты МА</p></td></tr><tr><td>features.ma_date_note_statuses</td><td><p>Список статусов даты МА</p></td></tr><tr><td>features.ma_label_crm</td><td><p>Group label CRM в рамках МА</p></td></tr><tr><td>features.ma_label_requests</td><td><p>Group label обращений в рамках МА</p></td></tr><tr><td>features.ma_label_sessions</td><td><p>Group label сессий в рамках МА</p></td></tr><tr><td>features.ma_label_views</td><td><p>Group label просмотров postview в рамках МА</p></td></tr><tr><td>features.ma_load_elements_ms</td><td><p>Время на получение элементов для разложения по МА, миллисекунд</p></td></tr><tr><td>features.ma_clear_analyzed_ms</td><td><p>Время на чистку кэша МА, миллисекунд</p></td></tr><tr><td>features.ma_fetch_analyzed_ms</td><td><p>Время на получение списка уже проанализированных элементов, миллисекунд</p></td></tr><tr><td>features.ma_analyze_ms</td><td><p>Время на разложение элементов по МА, миллисекунд</p></td></tr><tr><td>features.load_touches_for_request_ms</td><td><p>Время, затраченное на выгрузку касаний типа &quot;обращение&quot;, миллисекунд</p></td></tr><tr><td>features.load_touches_for_session_ms</td><td><p>Время, затраченное на выгрузку касаний типа &quot;сессия&quot;, миллисекунд</p></td></tr><tr><td>features.load_touches_for_view_ms</td><td><p>Время, затраченное на выгрузку касаний типа &quot;просмотр postview&quot;, миллисекунд</p></td></tr><tr><td>features.load_touches_for_crm_element_ms</td><td><p>Время, затраченное на выгрузку касаний типа &quot;CRM элемент&quot;, миллисекунд</p></td></tr><tr><td>features.load_touches_by_phones_for_request_ms</td><td><p>Время, затраченное на выгрузку касаний типа &quot;обращение&quot; при поиске по номеру телефона, миллисекунд</p></td></tr><tr><td>features.load_touches_by_phones_for_session_ms</td><td><p>Время, затраченное на выгрузку касаний типа &quot;сессия&quot; при поиске по номеру телефона, миллисекунд</p></td></tr><tr><td>features.load_touches_by_phones_for_view_ms</td><td><p>Время, затраченное на выгрузку касаний типа &quot;просмотр postview&quot; при поиске по номеру телефона, миллисекунд</p></td></tr><tr><td>features.load_touches_by_phones_for_crm_element_ms</td><td><p>Время, затраченное на выгрузку касаний типа &quot;CRM элемент&quot; при поиске по номеру телефона, миллисекунд</p></td></tr><tr><td>features.ma_closest_persons_ms</td><td><p>Время на поиск похожих персон, миллисекунд</p></td></tr><tr><td>features.project_id</td><td>Проект</td></tr></tbody></table><h3>Как это работает</h3><p>Положим мы строим показатель &quot;Верифицированные обращения&quot; (100),</p><p>который состоит из &quot;Все обращения&quot; (80),</p><p>который, в свою очередь, состоит из &quot;Звонки&quot; (70) и &quot;Обращения&quot; (60).</p><p>Для этого построения мы заведём 4 строки лога, на каждый из затронутых показателей.</p><p>При этом в каждой строке будут следующие данные:</p><p>metric_id именно от того показателя, который строим</p><p>metric_group_id - идентификатор показателя, с которого началось построение (100)</p><p>metric_parent_id - идентификатор группового показателя, который содержит текущий показатель: для звонков и обращений - 80, для Все обращения - 100</p><p>Связь между строками лога через parent_uuid.</p><p>При этом время построения/фильтрации/etc суммируется в рамках группы: время на построение верифицированных обращений = время на построение &quot;все обращения&quot; = время на построение &quot;звонки&quot; + время на построение &quot;обращения&quot;.</p><h3>Советы по использованию</h3><ul><li>Чтобы учесть вложенность (суммирование) времени построения, необходимо получать данные либо по конкретному показателю, либо по строкам, у которых parent_uuid IS NULL</li><li>Важно учитывать окружение, в котором был построен отчёт, т.к. в зависимости от окружения мы по разному используем построитель, да и лимиты разные:<ul><li>В большинстве случаев для&nbsp;<strong>server</strong><span>&nbsp;необходимо выставить <strong>prod </strong>- боевой сервер, которым пользуются клиенты</span></li><li>В большинстве случаев для&nbsp;<strong>sapi</strong>&nbsp;необходимо выставить <strong>fpm-fcgi</strong>&nbsp;- запросы непосредственно от клиентов. <strong>cli</strong> - для отчётов, которые строим мы сами</li><li>В большинстве случаев для <strong>deployment</strong>&nbsp;необходимо выставить&nbsp;<strong>php</strong>&nbsp;- именно через этот контейнер идут запросы из интерфейса. Для API необходимо использовать <strong>api</strong></li></ul></li></ul><p><br /></p>